#enter into the pod
$ kubectl exec -it <pod-name> -- bash
#if there is multiple container in the pod
$ kubectl exec -it <pod-name> -c <container-name> -- bash

#create a namespace
$ kubectl namespace <namespace-name>

#list the namespaces
$ kubectl get namespaces
#or
$ kubectl get ns

#set a namespace as the current one
$ kubectl config set-context --current --namespace=<namespace-name>

#launch a depÄºoyment
$ kubectl create deployment <deployment-name> --image=<docker-image>

#list the deployments
$ kubectl get deploy

#list the replica sets
$ kubectl get rs

#list the pods
$ kubectl get pods
#list the pods from all the namespaces
$ kubectl get pods -A

#list the pods with more info
$ kubectl get pods -o wide

#watch the pods in live mode, for live monitoring
$ kubectl get pods -w

#describe the pods
$ kubectl describe pods <pod-name>

#watch the pods with the labels
$ kubectl get pods --show-labels

#SELECTOR, like a query on the command based on the labels
$ kubectl get pods --selector <label>=<label-value>
#for example
$ kubectl get pods --selector environment=testing
#also can be used with a query
$ kubectl get pods --selector '<query>'
#for example
$ kubectl get pods --selector 'environment in (prod, dev, testing)'
$ kubectl get pods --selector 'environment notin (prod, dev, testing)'

#search by labels
$ kubectl get pods -l <label-name>
#for example
$ kubectl get pods -l environment

#watch the lastest entries of the logs of a pod
$ kubectl logs <pod-name>

#create a service, expose the deployment to the world
#the type LoadBalancer is the one that will expose it to the world
$ kubectl expose <deploy-name> --port=80 --name=<service-name> --type=LoadBalancer

#list the services
$ kubectl get svc
#the external-IP is the address to the world

#list the nodes on the cluste
$ kubectl get nodes

#list all the objects on the namespace
$ kubectl get all
#list with more details
$ kubectl get all -o wide

#list all the objects from another namespace
$ kubectl get all -n <namespace-name>

#############################DECLARATIVE WAY###################################
#apply a manifest
$ kubectl apply -f <YAML-file>
#in an specific namespace
$ kubectl apply -f <YAML-file> -n <ns-name>

#apply all the manifest in a directory
$ kubectl apply -f .
#or
$ kubectl apply -f <directory>

#delete the objects created by the manifest
$ kubectl delete -f <YAML-file>

#delete all the objects created with the manifests on the present directory
$ kubectl delete -f .

#############################IMPERAVITE WAY###################################
#apply without a manifest
$ kubectl create deploy --image=nginx:latest --replica=2 <deploy-name> 

#delete the objects created by the manifest
$ kubectl delete deploy <deploy-name>

#force kill for pod or any object
# kubectl delete pods -all --force --grace-period=0

##############################################################################

#scale replicasets or replicationcontrollers
$ kubectl scale rs <name> --replicas=5
$ kubectl scale rc <name> --replicas=5

#get the yaml for creation of any object
$ kubectl create ns <ns-name> --dry-run=client -o yaml

#expose a service to a port from the cluster
$ kubectl expose rs <rs-name> --port <port-number>
#example
$ kubectl expose rs landingpage --port 80

#delete a service
$ kubectl delete svc <service-name>

# get the yaml for the same
$ kubectl expose rs landingpage --port 80 --dry-run=client -o yaml

################rollout, command for deployments#####################

#see the history of changes on a deployment
$ kubectl rollout history deploy <deploy-name>

#display with details the revision
$ kubectl rollout history deploy <deploy-name> --revision=<revision-number>

#rollout to any previous revision of the deployment
$ kubectl rollout undo deploy <deploy-name> --to-revision=<revision-number>

#rollout to the immediately previous revision
$ kubectl rollout undo deploy <deploy-name> 

#edit the image without change the manifest
$ kubectl set image deploy <deploy-name> <container-name(from the manifest)>=<new-image>

#check the status of the rollout
$ kubectl rollout status deploy <deploy-name>

#add the change-cause to the history
$ kubectl annotate deploy <deploy-name> kubernetes.io/change-cause="<cause>"

########################Config Map#####################################
#RO volumes, only for congifuration

#yaml for cm from literal
$ kubectl create cm <cm-name> --from-literal <key>=<value> --dry-run=client -o yaml

#yaml for cm from file
$ kubectl create cm <cm-name> --from-file=<directory-path> --dry-run=client -o yaml

#port forwarding
$ kubectl port-forward <pod-name> <local-port>:<container-port>

#########################SECRETS##############################

#list the secrets
$ kubectl get secrets
#list the secrets for all the namespaces
$ kubectl get secrets -A

# create a secret
$ kubectl create secret <secret-type> <secret-name> --from-file=<file-name>
#example
# kubectl create secret generic creds --from-file=username.txt --from-file=password.txt

#get the info from secrets
$ kubectl describe secret <secret-name>
#or more usefull
$ kubectl get secret <secret-name> -o yaml
$ echo <encrypted-text> | base64 -d