#enter into the pod
$ kubectl exec -it <pod-name> -- bash
#if there is multiple container in the pod
$ kubectl exec -it <pod-name> -c <container-name> -- bash

#create a namespace
$ kubectl namespace <namespace-name>

#list the namespaces
$ kubectl get namespaces
#or
$ kubectl get ns

#set a namespace as the current one
$ kubectl config set-context --current --namespace=<namespace-name>

#launch a depÄºoyment
$ kubectl create deployment <deployment-name> --image=<docker-image>

#list the deployments
$ kubectl get deploy

#list the replica sets
$ kubectl get rs

#list the pods
$ kubectl get pods
#list the pods from all the namespaces
$ kubectl get pods -A

#list the pods with more info
$ kubectl get pods -o wide

#watch the pods in live mode, for live monitoring
$ kubectl get pods -w

#describe the pods
$ kubectl describe pods <pod-name>

#watch the pods with the labels
$ kubectl get pods --show-labels

#SELECTOR, like a query on the command based on the labels
$ kubectl get pods --selector <label>=<label-value>
#for example
$ kubectl get pods --selector environment=testing
#also can be used with a query
$ kubectl get pods --selector '<query>'
#for example
$ kubectl get pods --selector 'environment in (prod, dev, testing)'
$ kubectl get pods --selector 'environment notin (prod, dev, testing)'

#search by labels
$ kubectl get pods -l <label-name>
#for example
$ kubectl get pods -l environment

#watch the lastest entries of the logs of a pod
$ kubectl logs <pod-name>

#create a service, expose the deployment to the world
#the type LoadBalancer is the one that will expose it to the world
$ kubectl expose <deploy-name> --port=80 --name=<service-name> --type=LoadBalancer

#list the services
$ kubectl get svc
#the external-IP is the address to the world

#list the nodes on the cluste
$ kubectl get nodes

#list all the objects on the namespace
$ kubectl get all
#list with more details
$ kubectl get all -o wide

#list all the objects from another namespace
$ kubectl get all -n <namespace-name>

#############################DECLARATIVE WAY###################################
#apply a manifest
$ kubectl apply -f <YAML-file>
#in an specific namespace
$ kubectl apply -f <YAML-file> -n <ns-name>

#apply all the manifest in a directory
$ kubectl apply -f .
#or
$ kubectl apply -f <directory>

#delete the objects created by the manifest
$ kubectl delete -f <YAML-file>

#delete all the objects created with the manifests on the present directory
$ kubectl delete -f .

#############################IMPERAVITE WAY###################################
#apply without a manifest
$ kubectl create deploy --image=nginx:latest --replica=2 <deploy-name> 

#delete the objects created by the manifest
$ kubectl delete deploy <deploy-name>

#force kill for pod or any object
# kubectl delete pods -all --force --grace-period=0

##############################################################################

#scale replicasets or replicationcontrollers
$ kubectl scale rs <name> --replicas=5
$ kubectl scale rc <name> --replicas=5

#get the yaml for creation of any object
$ kubectl create ns <ns-name> --dry-run=client -o yaml

#expose a service to a port from the cluster
$ kubectl expose rs <rs-name> --port <port-number>
#example
$ kubectl expose rs landingpage --port 80

#delete a service
$ kubectl delete svc <service-name>

# get the yaml for the same
$ kubectl expose rs landingpage --port 80 --dry-run=client -o yaml